/*
Copyright (c) 2009-2011 by Pejman Attar, Yoann Canal, Juliusz Chroboczek and
                      Gabriel Kerneis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <assert.h>
#include <netdb.h>

#include <cpc/cpc_runtime.h>
#include <cpc/cpc_lib.h>

#include "util.h"
#include "hashtable.h"
#include "parse.h"
#include "server.h"
#include "torrent.h"
#include "tracker.h"
#include "list.h"
#include "io.h"

int peer_port = 6969;
char *peer_address = "::1";

#define BUF_LENGTH 2048
#define DIR_LEN 512

cpc_condvar *choke_cond;
cpc_condvar *close_cond;

int numpeers = 0;
int numunchoked = 0;
int maxpeers;
int maxunchoked = 50;
int initial_credit = 1024 * 1024;
int max_unchoked_time = 5 * 60;

struct peer *peers;

#define MAX(x, y) ((x) >= (y) ? (x) : (y))
#define MIN(x, y) ((x) >= (y) ? (y) : (x))

cps int
send_message_2(int fd, int id,
               char *body1, int bodylen1, char *body2, int bodylen2)
{
    unsigned char buf[5];
    struct iovec iov[3];
    int i, rc;

    debugf(10, "%3d -> type = %d, length = %d\n",
           fd, id, bodylen1 + bodylen2 + 1);

    DO_HTONL(buf, bodylen1 + bodylen2 + 1);
    buf[4] = id;

    i = 0;

    iov[i].iov_base = buf;
    iov[i].iov_len = 5;
    i++;

    if(bodylen1 > 0) {
        iov[i].iov_base = body1;
        iov[i].iov_len = bodylen1;
        i++;
    }

    if(bodylen2 > 0) {
        iov[i].iov_base = body2;
        iov[i].iov_len = bodylen2;
        i++;
    }

    rc = cpc_full_writev(fd, iov, i);
    if(rc < 5)
        return -1;

    return 1;
}

cps int
send_message(int fd, int id, char *body, int bodylen)
{
    return send_message_2(fd, id, body, bodylen, NULL, 0);
}

cps int
send_message_h(int fd, char *head, int headlen,
               int id, char *body, int bodylen)
{
    unsigned char buf[5];
    struct iovec iov[3];
    int i, rc;

    debugf(10, "%3d -> h=%d, type = %d, length = %d\n",
           fd, headlen, id, bodylen + 1);

    DO_HTONL(buf, bodylen + 1);
    buf[4] = id;

    i = 0;

    if(headlen > 0) {
        iov[i].iov_base = head;
        iov[i].iov_len = headlen;
        i++;
    }

    iov[i].iov_base = buf;
    iov[i].iov_len = 5;
    i++;

    if(bodylen > 0) {
        iov[i].iov_base = body;
        iov[i].iov_len = bodylen;
        i++;
    }

    rc = cpc_full_writev(fd, iov, i);
    if(rc < 5)
        return -1;

    return 1;
}

cps int
send_bitfield(int fd, struct torrent *t, char *head, int headlen)
{
    int length = 0;
    unsigned char *buf= NULL;
    int rc;

    length = (t->num_chunks - 1) / 8 + 1;

    buf = malloc(length);
    if(!buf) {
        perror("(send_bitfield)malloc");
        return -1;
    }

    memset(buf, 0, length);

    rc = send_message_h(fd, head, headlen, 5, buf, length);
    if(rc < 0) {
        perror("(send_bitfield)cpc_message");
        free(buf);
        return -1;
    }

    free(buf);
    return 1;
}

cps int
send_interested(int fd)
{
    int rc;

    rc = send_message(fd, 2, NULL, 0);
    if(rc < 0) {
        perror("(send_interested)cpc_full_write");
        return -1;
    }
    return 0;
}

cps int
send_request(int fd, int index, int begin, int length)
{
    int rc;
    unsigned char buf[12];

    DO_HTONL(buf, index);
    DO_HTONL(buf + 4, begin);
    DO_HTONL(buf + 8, length);
    rc = send_message(fd, 6, buf, 12);
    if(rc < 0) {
        perror("(send_request)cpc_full_write");
        return -1;
    }
    return 0;
}

/* return -1 if sth wrong happend in handshake otherwise return 0 */
cps int
handshake(int fd)
{
    int rc, i;
    const char *protocol = "\023BitTorrent protocol";
    char *res = NULL, id[41];
    struct torrent *torrent = NULL;
    cpc_buffer *b = cpc_buffer_get(68);

    torrent = peers[fd].t;

    for(i = 0; i<20; i++)
        snprintf(id + 2 * i, 3, "%.2x", torrent->info_hash[i]);

    assert(torrent);

    debugf(2, "%3d torrent requested: %s\n", fd, id);

    peers[fd].credit = 0;

    res = malloc(1 + 19 + 8 + 20 + 20);

    strncpy(res, protocol, 20);

    memset(res + 20, 0, 8);

    memcpy(res + 28, torrent->info_hash, 20);
    memcpy(res + 48, peer_id, 20);

    rc = send_bitfield(fd, torrent, res, 68);
    free(res);
    if(rc < 0)
        goto fail;

    /* Read the rest of the client handshake. */
    rc = cpc_buffer_read(fd, b, 68);
    if(rc < 68) {
        perror("(handshake)cpc_buffer_read");
        goto fail;
    }

    if(memcmp(b->buf, protocol, 20) != 0) {
        for(i = 0; i<20; i++) {
            unsigned char c = b->buf[i];
            snprintf(id + i, 2, "%c", c >= 0x21 && c <= 0x7E ? c : '.');
        }
        debugf(1, "%3d bad protocol: %s\n", fd, id);
        goto fail;
    }

    peers[fd].dht = 0;
    peers[fd].ltep = 0;

    for(i = 0; i < 20; i++) {
        unsigned char c = b->buf[48 + i];
        snprintf(id + i, 2, "%c", c >= 0x21 && c <= 0x7E ? c : '.');
    }
    debugf(2, "%3d peer-id %s %s%s\n",
           fd, id,
           peers[fd].dht ? " (DHT)" : "",
           peers[fd].ltep ? " (LTEP)" : "");

    cpc_buffer_destroy(b);
    return 0;

fail:
    cpc_buffer_destroy(b);
    return -1;
}

cps int
stream_reader(int fd)
{
    uint32_t length = 0;
    cpc_buffer *b = cpc_buffer_get(BUF_LENGTH);
    uint32_t begin, index, chunk_len;
    int rc, type;

    srand(1);

    while(1) {
        if(peers[fd].dying)
            goto fail;


        rc = cpc_buffer_read(fd, b, 4);
        if(rc < 4)
            goto fail;

        assert(b->end - b->start >= 4);

        DO_NTOHL(length, b->buf + b->start);
        b->start += 4;

        int to_read = 0;

        if(length > BUF_LENGTH) {
            to_read = length;
            length = BUF_LENGTH - 4;
        }

        rc = cpc_buffer_read(fd, b, length);
        if(rc < (int32_t) length)
            goto fail;

        assert(b->end - b->start >= length);

        /* keep-alive */
        if(length == 0)
            continue;

        type = b->buf[b->start];

        if(to_read > 0) {
          debugf(10, "%3d <- type = %d, length = %d\n", fd, type, to_read);
          if(type != 7) {
            debugf(3, "%3d message too long!\n", fd);
            goto fail;
          }
        } else {
          debugf(10, "%3d <- type = %d, length = %d\n", fd, type, length);
        }

        if(type != 5 && type != 20 && type != 7 && length > 20) {
            debugf(1, "%3d unbelievably long message!\n", fd);
            goto fail;
        }

        b->start += length;

        switch(type) {
        case 0:
            peers[fd].unchoked = 0;
            numunchoked--;
            break;

        case 1:
            peers[fd].unchoked = 1;
            send_request(fd, rand() % peers[fd].t->num_chunks,
                rand() % ((peers[fd].t->p_length / 0x8000) * peers[fd].t->p_length),  0x8000);
            numunchoked++;
            break;

        case 2: case 3: case 4: case 5: case 6: case 8: case 9: case 20:
            break;

        case 7:
            debugf(3, "%3d got some piece!\n", fd);
            if(to_read > 0) {
                assert(length + 4 == BUF_LENGTH);
                to_read -= length;
                /* Read the rest of the piece */
                while(to_read > 0) {
                    rc = cpc_buffer_read(fd, b, MIN(to_read, BUF_LENGTH));
                    if(rc < 0) {
                        debugf(1, "%3d cpc_buffer_read failed\n", fd);
                        goto fail;
                    }
                    assert(b->start == 0);
                    assert(b->end == rc);
                    b->start = MIN(to_read, BUF_LENGTH); /* invalidate buffer */
                    to_read -= rc;
                }
            }
            send_request(fd, rand() % peers[fd].t->num_chunks,
                rand() % (peers[fd].t->p_length / 0x8000) * peers[fd].t->p_length,  0x8000);
             break;
 
        default:
            debugf(1, "%3d unexpected message\n", fd);
            goto fail;
        }
    }
 fail:
    cpc_buffer_destroy(b);
    return -1;
}

void
free_chunk_list(struct chunk* c)
{
    struct chunk *next;
    while(c) {
        next = c->next;
        free(c);
        c = next;
    }
}

void
free_chunks(int fd)
{
    free_chunk_list(peers[fd].list);
    peers[fd].list = NULL;
    return ;
}

cps void
client(int client_fd)
{
    int rc = 0, error = 0, len = 0;


    cpc_io_wait(client_fd, CPC_IO_OUT);
    if(getsockopt(client_fd, SOL_SOCKET, SO_ERROR, &error, &len) < 0 ||
            error != 0) {
        debugf(1, "%3d connect failed\n", client_fd);
        goto done;
    }

    rc = handshake(client_fd);
    if(rc < 0) {
        debugf(1, "%3d broken handshake -- dropping\n", client_fd);
        goto done;
    }

    rc = send_interested(client_fd);

    if(rc < 0) {
        debugf(1, "%3d Come on, I *was* interested!\n", client_fd);
        goto done;
    }

    rc = stream_reader(client_fd);

 done:
    debugf(1, "%3d closing\n", client_fd);
    free_chunks(client_fd);
    peers[client_fd].t = NULL;


    if(peers[client_fd].unchoked) {
        numunchoked--;
        cpc_signal(choke_cond);
    }

    assert(numpeers >= 1);
    numpeers--;

    memset(&peers[client_fd], 0, sizeof(struct peer));

    close(client_fd);

    cpc_signal(close_cond);
    return;
}

cps void
connecting(hashtable * table)
{
    struct sockaddr_in6 sin6;
    struct torrent *torrent = table->table[0]; /* XXX use only the first torrent */
    int client_fd, i=0, flags;
    int fd_max, rc;

    maxpeers = maxunchoked;
    fd_max = maxpeers + 10;
    peers =  calloc(fd_max, sizeof(struct peer));
    if(!peers) {
        perror("(listening)calloc");
        return;
    }

    choke_cond = cpc_condvar_get();
    close_cond = cpc_condvar_get();

    while(1) {
        while(numpeers >= maxpeers)
            cpc_wait(close_cond);
        torrent = torrent == NULL ? NULL : torrent->next;
        while(!torrent) {
            i = (i+1) % table->size;
            torrent = table->table[i];
        }

        client_fd = socket(PF_INET6, SOCK_STREAM, 0);
        if(client_fd<0) {
            perror("socket");
            exit(1);
        }

        flags = fcntl(client_fd, F_GETFL);
        if(flags < 0) {
            perror("F_GETFL");
            close(client_fd);
            continue;
        }

        rc = fcntl(client_fd, F_SETFL, flags|O_NONBLOCK);
        if(rc < 0) {
            perror("F_SETFL");
            close(client_fd);
            continue;
        }

        memset(&sin6, 0, sizeof(sin6));
        sin6.sin6_family = AF_INET6;
        sin6.sin6_port = htons(peer_port);
        inet_pton(AF_INET6, peer_address, &sin6.sin6_addr);

        if(connect(client_fd, (struct sockaddr *)&sin6, sizeof(sin6)) < 0 &&
                errno != EINPROGRESS) {
            perror("connect");
            close(client_fd);
            continue;
         }
        numpeers++;
        assert(!peers[client_fd].t);
        peers[client_fd].t = torrent;
        cpc_spawn client(client_fd);
    }

    return;
}
